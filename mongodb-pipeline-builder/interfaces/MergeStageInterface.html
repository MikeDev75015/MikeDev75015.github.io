<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>mongodb-pipeline-builder documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">mongodb-pipeline-builder documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>MergeStageInterface</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>lib/interfaces/stages/merge-stage.interface.ts</code>
        </p>

            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>Merge Stage Interface</p>

            </p>


        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#into">into</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#let">let</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#on">on</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#whenMatched">whenMatched</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#whenNotMatched">whenNotMatched</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="into"></a>
                                        <span class="name"><b>into</b><a href="#into"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>into:         <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >any</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >any</a></code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>The output collection. Specify either:</p>
<p>The collection name as a string to output to a collection in the same database where the aggregation is run. For
example:</p>
<p>into: &quot;myOutput&quot;</p>
<p>The database and collection name in a document to output to a collection in the specified database. For example:</p>
<p>into: { db:&quot;myDB&quot;, coll:&quot;myOutput&quot; }</p>
<p>NOTE</p>
<p>If the output collection does not exist, $merge creates the collection:</p>
<p>For a replica set or a standalone, if the output database does not exist, $merge also creates the database.</p>
<p>For a sharded cluster, the specified output database must already exist.</p>
<p>The output collection can be a sharded collection.</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="let"></a>
                                        <span class="name"><b>let</b><a href="#let"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>let:     <code>literal type</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>literal type</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>Optional. Specifies variables accessible for use in the whenMatched pipeline</p>
<p>Specify a document with the variable name and value expression:</p>
<p>{ <var_1>: <expression>, ..., <var_n>: <expression> }</p>
<p>If unspecified, defaults to { new: &quot;$$ROOT&quot; }; i.e. the whenMatched pipeline can access the $$new variable.</p>
<p>NOTE</p>
<p>Starting in MongoDB 4.2.2, the $$new variable is reserved, and cannot be overridden.</p>
<p>To access the let variables in the whenMatched pipeline, use the double dollar signs ($$) prefix and variable
name $$<variable>.</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="on"></a>
                                        <span class="name"><b>on</b><a href="#on"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>on:     <code>string | string[]</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>string | string[]</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>Optional. Field or fields that act as a unique identifier for a document. The identifier determines if a results
document matches an already existing document in the output collection. Specify either:</p>
<p>A single field name as a string. For example:</p>
<p>on: &quot;_id&quot;</p>
<p>A combination of fields in an array. For example:</p>
<p>on: [ &quot;date&quot;, &quot;customerId&quot; ]</p>
<p>The order of the fields in the array does not matter, and you cannot specify the same field multiple times.</p>
<p>For the specified field or fields:</p>
<p>The aggregation results documents must contain the field(s) specified in the on, unless the on field is the _id
field. If the _id field is missing from a results document, MongoDB adds it automatically.
The specified field or fields cannot contain a null or an array value.
$merge requires a unique, index with keys that correspond to the on identifier fields. Although the order of the
index key specification does not matter, the unique index must only contain the on fields as its keys.</p>
<p>The index must also have the same collation as the aggregation’s collation.
The unique index can be a sparse index.
For output collections that already exist, the corresponding index must already exist.
The default value for on depends on the output collection:</p>
<p>If the output collection does not exist, the on identifier must be and defaults to the _id field. The
corresponding unique _id index is automatically created.</p>
<p>TIP</p>
<p>To use a different on identifier field(s) for a collection that does not exist, you can create the collection
first by creating a unique index on the desired field(s). See the section on non-existent output collection for
an example.</p>
<p>If the existing output collection is unsharded, the on identifier defaults to the _id field.</p>
<p>If the existing output collection is a sharded collection, the on identifier defaults to all the shard key fields
and the _id field. If specifying a different on identifier, the on must contain all the shard key fields.</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="whenMatched"></a>
                                        <span class="name"><b>whenMatched</b><a href="#whenMatched"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>whenMatched:     <code>&quot;replace&quot; | &quot;keepExisting&quot; | &quot;merge&quot; | &quot;fail&quot; | &quot;pipeline&quot;</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>&quot;replace&quot; | &quot;keepExisting&quot; | &quot;merge&quot; | &quot;fail&quot; | &quot;pipeline&quot;</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>Optional. The behavior of $merge if a result document and an existing document in the collection have the same
value for the specified on field(s).</p>
<p>You can specify either:</p>
<p>One of the pre-defined action strings:</p>
<p>Action    Description</p>
<p>“replace”</p>
<p>Replace the existing document in the output collection with the matching results document.
When performing a replace, the replacement document cannot result in a modification of the _id value or, if the
output collection is sharded, the shard key value. Otherwise, the operation results in an error.</p>
<p>TIP</p>
<p>To avoid this error, if the on field does not include the _id field, remove the _id field in the aggregation
results to avoid the error, such as with a preceding $unset stage, etc.</p>
<p>“keepExisting”</p>
<p>Keep the existing document in the output collection.
“merge” (Default)
Merge the matching documents (similar to the $mergeObjects operator).</p>
<p>If the results document contains fields not in the existing document, add these new fields to the existing
document.
If the results document contains fields in the existing document, replace the existing field values with those
from the results document.
For example, if the output collection has the document:</p>
<p>{ _id: 1, a: 1, b: 1 }</p>
<p>And the aggregation results has the document:</p>
<p>{ _id: 1, b: 5, z: 1 }</p>
<p>Then, the merged document is:</p>
<p>{ _id: 1, a: 1, b: 5, z: 1 }</p>
<p>When performing a merge, the merged document cannot result in a modification of the _id value or, if the output
collection is sharded, the shard key value. Otherwise, the operation results in an error.</p>
<p>TIP</p>
<p>To avoid this error, if the on field does not include the _id field, remove the _id field in the aggregation
results to avoid the error, such as with a preceding $unset stage, etc.</p>
<p>“fail”</p>
<p>Stop and fail the aggregation operation. Any changes to the output collection from previous documents are not
reverted.</p>
<p>An aggregation pipeline to update the document in the collection.</p>
<p>[ <stage1>, <stage2> ... ]</p>
<p>The pipeline can only consist of the following stages:</p>
<p>$addFields and its alias $set
$project and its alias $unset
$replaceRoot and its alias $replaceWith
The pipeline cannot modify the on field’s value. For example, if you are matching on the field month, the
pipeline cannot modify the month field.</p>
<p>The whenMatched pipeline can directly access the fields of the existing documents in the output collection using
$<field>.</p>
<p>To access the fields from the aggregation results documents, use either:</p>
<p>The built-in $$new variable to access the field, i.e. $$new.<field>. The $$new variable is only available if the
let specification is omitted.</p>
<p>NOTE</p>
<p>Starting in MongoDB 4.2.2, the $$new variable is reserved, and cannot be overridden.</p>
<p>The user-defined variables in the let field, i.e. $$<uservariable>.<field>.</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="whenNotMatched"></a>
                                        <span class="name"><b>whenNotMatched</b><a href="#whenNotMatched"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>whenNotMatched:     <code>&quot;insert&quot; | &quot;discard&quot; | &quot;fail&quot;</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>&quot;insert&quot; | &quot;discard&quot; | &quot;fail&quot;</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>Optional. The behavior of $merge if a result document does not match an existing document in the out collection.</p>
<p>You can specify one of the pre-defined action strings:</p>
<p>Action    Description</p>
<p>“insert” (Default)</p>
<p>Insert the document into the output collection.</p>
<p>“discard”</p>
<p>Discard the document; i.e. $merge does not insert the document into the output collection.</p>
<p>“fail”</p>
<p>Stop and fail the aggregation operation. Any changes already written to the output collection are not reverted.</p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">export interface MergeStageInterface {
    /**
     * The output collection. Specify either:
     *
     * The collection name as a string to output to a collection in the same database where the aggregation is run. For
     * example:
     *
     * into: &quot;myOutput&quot;
     *
     * The database and collection name in a document to output to a collection in the specified database. For example:
     *
     * into: { db:&quot;myDB&quot;, coll:&quot;myOutput&quot; }
     *
     * NOTE
     *
     * If the output collection does not exist, $merge creates the collection:
     *
     * For a replica set or a standalone, if the output database does not exist, $merge also creates the database.
     *
     * For a sharded cluster, the specified output database must already exist.
     *
     * The output collection can be a sharded collection.
     */
    into: any;
    /**
     * Optional. Field or fields that act as a unique identifier for a document. The identifier determines if a results
     * document matches an already existing document in the output collection. Specify either:
     *
     * A single field name as a string. For example:
     *
     * on: &quot;_id&quot;
     *
     * A combination of fields in an array. For example:
     *
     * on: [ &quot;date&quot;, &quot;customerId&quot; ]
     *
     * The order of the fields in the array does not matter, and you cannot specify the same field multiple times.
     *
     * For the specified field or fields:
     *
     * The aggregation results documents must contain the field(s) specified in the on, unless the on field is the _id
     * field. If the _id field is missing from a results document, MongoDB adds it automatically.
     * The specified field or fields cannot contain a null or an array value.
     * $merge requires a unique, index with keys that correspond to the on identifier fields. Although the order of the
     * index key specification does not matter, the unique index must only contain the on fields as its keys.
     *
     * The index must also have the same collation as the aggregation’s collation.
     * The unique index can be a sparse index.
     * For output collections that already exist, the corresponding index must already exist.
     * The default value for on depends on the output collection:
     *
     * If the output collection does not exist, the on identifier must be and defaults to the _id field. The
     * corresponding unique _id index is automatically created.
     *
     * TIP
     *
     * To use a different on identifier field(s) for a collection that does not exist, you can create the collection
     * first by creating a unique index on the desired field(s). See the section on non-existent output collection for
     * an example.
     *
     * If the existing output collection is unsharded, the on identifier defaults to the _id field.
     *
     * If the existing output collection is a sharded collection, the on identifier defaults to all the shard key fields
     * and the _id field. If specifying a different on identifier, the on must contain all the shard key fields.
     */
    on?: string | string[];
    /**
     * Optional. The behavior of $merge if a result document and an existing document in the collection have the same
     * value for the specified on field(s).
     *
     * You can specify either:
     *
     * One of the pre-defined action strings:
     *
     * Action	Description
     *
     * “replace”
     *
     * Replace the existing document in the output collection with the matching results document.
     * When performing a replace, the replacement document cannot result in a modification of the _id value or, if the
     * output collection is sharded, the shard key value. Otherwise, the operation results in an error.
     *
     * TIP
     *
     * To avoid this error, if the on field does not include the _id field, remove the _id field in the aggregation
     * results to avoid the error, such as with a preceding $unset stage, etc.
     *
     * “keepExisting”
     *
     * Keep the existing document in the output collection.
     * “merge” (Default)
     * Merge the matching documents (similar to the $mergeObjects operator).
     *
     * If the results document contains fields not in the existing document, add these new fields to the existing
     * document.
     * If the results document contains fields in the existing document, replace the existing field values with those
     * from the results document.
     * For example, if the output collection has the document:
     *
     * { _id: 1, a: 1, b: 1 }
     *
     * And the aggregation results has the document:
     *
     * { _id: 1, b: 5, z: 1 }
     *
     * Then, the merged document is:
     *
     * { _id: 1, a: 1, b: 5, z: 1 }
     *
     * When performing a merge, the merged document cannot result in a modification of the _id value or, if the output
     * collection is sharded, the shard key value. Otherwise, the operation results in an error.
     *
     * TIP
     *
     * To avoid this error, if the on field does not include the _id field, remove the _id field in the aggregation
     * results to avoid the error, such as with a preceding $unset stage, etc.
     *
     * “fail”
     *
     * Stop and fail the aggregation operation. Any changes to the output collection from previous documents are not
     * reverted.
     *
     * An aggregation pipeline to update the document in the collection.
     *
     * [ &lt;stage1&gt;, &lt;stage2&gt; ... ]
     *
     * The pipeline can only consist of the following stages:
     *
     * $addFields and its alias $set
     * $project and its alias $unset
     * $replaceRoot and its alias $replaceWith
     * The pipeline cannot modify the on field’s value. For example, if you are matching on the field month, the
     * pipeline cannot modify the month field.
     *
     * The whenMatched pipeline can directly access the fields of the existing documents in the output collection using
     * $&lt;field&gt;.
     *
     * To access the fields from the aggregation results documents, use either:
     *
     * The built-in $$new variable to access the field, i.e. $$new.&lt;field&gt;. The $$new variable is only available if the
     * let specification is omitted.
     *
     * NOTE
     *
     * Starting in MongoDB 4.2.2, the $$new variable is reserved, and cannot be overridden.
     *
     * The user-defined variables in the let field, i.e. $$&lt;uservariable&gt;.&lt;field&gt;.
     */
    whenMatched?: &#x27;replace&#x27; | &#x27;keepExisting&#x27; | &#x27;merge&#x27; | &#x27;fail&#x27; | &#x27;pipeline&#x27;;
    /**
     * Optional. Specifies variables accessible for use in the whenMatched pipeline
     *
     * Specify a document with the variable name and value expression:
     *
     * { &lt;var_1&gt;: &lt;expression&gt;, ..., &lt;var_n&gt;: &lt;expression&gt; }
     *
     * If unspecified, defaults to { new: &quot;$$ROOT&quot; }; i.e. the whenMatched pipeline can access the $$new variable.
     *
     * NOTE
     *
     * Starting in MongoDB 4.2.2, the $$new variable is reserved, and cannot be overridden.
     *
     * To access the let variables in the whenMatched pipeline, use the double dollar signs ($$) prefix and variable
     * name $$&lt;variable&gt;.
     */
    let?: { [key: string]: any; };
    /**
     * Optional. The behavior of $merge if a result document does not match an existing document in the out collection.
     *
     * You can specify one of the pre-defined action strings:
     *
     * Action	Description
     *
     * “insert” (Default)
     *
     * Insert the document into the output collection.
     *
     * “discard”
     *
     * Discard the document; i.e. $merge does not insert the document into the output collection.
     *
     * “fail”
     *
     * Stop and fail the aggregation operation. Any changes already written to the output collection are not reverted.
     */
    whenNotMatched?: &#x27;insert&#x27; | &#x27;discard&#x27; | &#x27;fail&#x27;;
}
</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'MergeStageInterface.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
